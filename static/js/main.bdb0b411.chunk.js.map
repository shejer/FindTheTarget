{"version":3,"sources":["Result.js","decompose.js","possibleResults.js","hiddenNumber.js","index.js"],"names":["Result","result","showTarget","useState","isVisible","setVisible","className","success","onClick","target","steps","map","step","index","key","concat","element","array","length","e","decompose","number","substr","rawDecomposition","filter","decomposition","some","str","test","possibleResults","results","indexesUsedForResult","operations","i","j","add","push","sub","Math","abs","len","max","min","recontructHost","usedIndexes","newHost","doesItStartWith","potentialStart","answer","newTarget","hiddenNumber","host","usedLast","reset","decompositions","d","r","toSaveorNotToSave","indexes","indexOf","o","usedLastHere","TARGETS_TO_TEST","ReactDOM","render","state","setState","onChange","name","value","forEach","type","autoFocus","document","getElementById"],"mappings":"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","file":"static/js/main.bdb0b411.chunk.js","sourcesContent":["import React, { useState } from \"react\";\n\nexport default function Result({ result, showTarget = true }) {\n  const [isVisible, setVisible] = useState(false);\n\n  return (\n    <div className={result.success ? \"SUCCESS\" : \"\"}>\n      <span onClick={() => setVisible(!isVisible)} className=\"base-result\">\n        {showTarget ? result.target : result.success ? \"SUCCESS\" : \"FAIL\"}\n      </span>\n      {isVisible && result.success && (\n        <ol>\n          {result.steps.map((step, index) => (\n            <li key={index}>\n              <pre>{step}</pre>\n            </li>\n          ))}\n        </ol>\n      )}\n    </div>\n  );\n}\n","// precondition : array has 2 dimensions\n// concat adds element in the beginning of each array component\nfunction concat(element, array) {\n  if (array.length === 0) {\n    return [[element]];\n  }\n\n  return array.map(e => [element, ...e]);\n}\n\nfunction rawDecomposition(number) {\n  if (number.length === 0) {\n    return [];\n  }\n\n  if (number.length === 1) {\n    //  console.log(\"case 1 : \", [[number]]);\n    return [[number]];\n  }\n\n  if (number.length === 2) {\n    //console.log(\"case 2 : \", [[number[0], number[1]], [number]]);\n    return [[number[0], number[1]], [number]];\n  }\n\n  if (number.length === 3) {\n    return [\n      [number.substr(0, 1), number.substr(1, 1), number.substr(2, 1)],\n      [number.substr(0, 1), number.substr(1, 2)],\n      [number.substr(0, 2), number.substr(2, 1)],\n      [number]\n    ];\n  }\n\n  return [\n    ...concat(number.substr(0, 1), decompose(number.substr(1))),\n    ...concat(number.substr(0, 2), decompose(number.substr(2))),\n    ...concat(number.substr(0, 3), decompose(number.substr(3))),\n    ...concat(number.substr(0, 4), decompose(number.substr(4)))\n  ];\n}\n\nexport default function decompose(number) {\n  const decompositions = rawDecomposition(number);\n  return decompositions.filter(decomposition => {\n    return !decomposition.some(str => /0+(.+)/.test(str));\n  });\n}\n","export default function possibleResults(decomposition) {\n  const results = [];\n  const indexesUsedForResult = [];\n  const operations = [];\n\n  // This loop computes all possible combinations between two elements of decomposition\n  for (let i = 0; i < decomposition.length - 1; i++) {\n    const j = i + 1;\n    const add = 1 * decomposition[i] + 1 * decomposition[j];\n    results.push(`${add}`);\n    indexesUsedForResult.push([i, j]);\n    operations.push(`(${decomposition[i]} + ${decomposition[j]} = ${add})`);\n\n    const sub = Math.abs(1 * decomposition[i] - 1 * decomposition[j]);\n    results.push(`${sub}`);\n    indexesUsedForResult.push([i, j]);\n    operations.push(`(${decomposition[i]} - ${decomposition[j]} = ${sub})`);\n  }\n\n  // At this point results only contain combinations of two elements of decomposition\n  const len = results.length;\n\n  //This loop computes all possible results between a combination and an element of decomposition\n  for (let i = 0; i < len; i++) {\n    const j = Math.max(...indexesUsedForResult[i]) + 1;\n    if (j < decomposition.length) {\n      const add = 1 * results[i] + 1 * decomposition[j];\n      results.push(`${add}`);\n      indexesUsedForResult.push([...indexesUsedForResult[i], j]);\n      operations.push(\n        `${operations[i]} (${results[i]} + ${decomposition[j]} = ${add})`\n      );\n\n      const sub = Math.abs(1 * results[i] - 1 * decomposition[j]);\n      results.push(`${sub}`);\n      indexesUsedForResult.push([...indexesUsedForResult[i], j]);\n      operations.push(\n        `${operations[i]} (${results[i]} - ${decomposition[j]} = ${sub})`\n      );\n    }\n  }\n\n  // This loop computes all possible results that are combinations between two combinations\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (\n        Math.max(...indexesUsedForResult[i]) + 1 ===\n        Math.min(...indexesUsedForResult[j])\n      ) {\n        const add = 1 * results[i] + 1 * results[j];\n        results.push(`${add}`);\n        indexesUsedForResult.push([\n          ...indexesUsedForResult[i],\n          ...indexesUsedForResult[j]\n        ]);\n        operations.push(\n          `${operations[i]} ${operations[j]} (${results[i]} + ${results[j]} = ${add})`\n        );\n\n        const sub = Math.abs(1 * results[i] - 1 * results[j]);\n        results.push(`${sub}`);\n        indexesUsedForResult.push([\n          ...indexesUsedForResult[i],\n          ...indexesUsedForResult[j]\n        ]);\n        operations.push(\n          `${operations[i]} ${operations[j]} (${results[i]} - ${results[j]} = ${sub})`\n        );\n      }\n    }\n  }\n\n  return { results, indexesUsedForResult, operations };\n}\n","import decompose from \"./decompose\";\nimport possibleResults from \"./possibleResults\";\n\n// starts from a decomposition of a host and used indexes from the previous step\n// and recontructs the new host to work with\nfunction recontructHost(decomposition, usedIndexes) {\n  let newHost = \"\";\n  for (let i of usedIndexes) {\n    newHost += decomposition[i];\n  }\n  for (\n    let i = usedIndexes[usedIndexes.length - 1] + 1;\n    i < decomposition.length;\n    i++\n  ) {\n    newHost += decomposition[i];\n  }\n  return newHost;\n}\n\n// doesItStartWith verifies if target starts with potentialStart\n// In which case, answer is true and newTarget is the remaining part of target\n// Otherwise, answer is false and newTarget is empty\nexport function doesItStartWith(potentialStart, target) {\n  let answer = target.substr(0, potentialStart.length) === potentialStart;\n  let newTarget = \"\";\n  if (answer) {\n    newTarget = target.substr(potentialStart.length);\n  }\n  return { answer, newTarget };\n}\n\nexport default function hiddenNumber(target, host, usedLast, reset = false) {\n  if (reset) {\n    usedLast = false;\n  }\n\n  let decompositions = decompose(host);\n\n  for (let d of decompositions) {\n    let { results, indexesUsedForResult, operations } = possibleResults(d);\n    if (reset) {\n      const toSaveorNotToSave = indexesUsedForResult.map(\n        indexes => indexes.indexOf(0) >= 0\n      );\n      indexesUsedForResult = indexesUsedForResult.filter(\n        (indexes, i) => toSaveorNotToSave[i]\n      );\n      results = results.filter((r, i) => toSaveorNotToSave[i]);\n      operations = operations.filter((o, i) => toSaveorNotToSave[i]);\n    }\n\n    for (let r in results) {\n      let usedLastHere = usedLast;\n      let { answer, newTarget } = doesItStartWith(results[r], target);\n      if (answer) {\n        if (!usedLastHere && newTarget === \"\") {\n          usedLastHere =\n            indexesUsedForResult[r][indexesUsedForResult[r].length - 1] ===\n            d.length - 1;\n        }\n        // console.log({ usedLastHere, d, indexes: indexesUsedForResult[r] });\n        // console.log({\n        //   host,\n        //   step: operations[r],\n        //   potentialStart: results[r],\n        //   target,\n        //   newTarget,\n        //   indexes: indexesUsedForResult[r]\n        // });\n\n        if (newTarget === \"\" && usedLastHere) {\n          return { target, success: true, steps: [operations[r]] };\n        }\n        let newHost = recontructHost(d, indexesUsedForResult[r]);\n        let { success, steps } = hiddenNumber(newTarget, newHost, usedLastHere);\n        if (success && steps.indexOf(operations[r]) < 0) {\n          return { target, success, steps: [operations[r], ...steps] };\n        }\n      }\n    }\n  }\n\n  return { target, success: false, steps: [] };\n}\n","import React, { useState } from \"react\";\nimport ReactDOM from \"react-dom\";\n//import \"./test.js\";\n\nimport Result from \"./Result\";\n\nimport \"./styles.css\";\n\nimport hiddenNumber from \"./hiddenNumber\";\n\nconst TARGETS_TO_TEST = [\n  \"396\",\n  \"12922\",\n  \"693\",\n  \"129225\",\n  \"69\",\n  \"22912\",\n  \"39\",\n  \"229125\",\n  \"36\",\n  \"495\",\n  \"96\",\n  \"594\",\n  \"93\"\n];\n\nfunction App() {\n  const [state, setState] = useState({ target: \"\", host: \"\" });\n\n  const onChange = ({ target: { name, value } }) => {\n    setState({ ...state, [name]: value });\n  };\n\n  const results = [];\n  let result;\n\n  if (state.host) {\n    result =\n      state.target && hiddenNumber(state.target, state.host, false, true);\n\n    TARGETS_TO_TEST.forEach(target => {\n      results.push(hiddenNumber(target, state.host, false, true));\n    });\n  }\n\n  return (\n    <>\n      <h1>Find The Target</h1>\n      <div className=\"form\">\n        <label>\n          <span>Target:</span>\n          <input\n            type=\"number\"\n            name=\"target\"\n            value={state.target}\n            onChange={onChange}\n            autoFocus={true}\n          />\n        </label>\n        <label>\n          <span>Host:</span>\n          <input\n            type=\"number\"\n            name=\"host\"\n            value={state.host}\n            onChange={onChange}\n          />\n        </label>\n        {result && (\n          <Result key={result.target} result={result} showTarget={false} />\n        )}\n      </div>\n      <div className=\"grid\">\n        {results.map(result => (\n          <Result key={result.target} result={result} />\n        ))}\n      </div>\n    </>\n  );\n}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}